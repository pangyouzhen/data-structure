# 动态规划

## 什么是动态规划

求解动态规划的核心问题是**穷举**，但是动态规划有**最优子结构**和**重叠子问题**,所以进行穷举

动态规划问题最困难的就是写出状态转移方程，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。

## 什么情况下使用

1） 计数 2） 最值 3）

## 状态转移方程

1. 明确 [状态]
1. 定义 dp 数组/函数的含义
1. 明确「选择」
1. 明确 base case。

## 两种方法

1. 记忆化递归
2. dp

## 典型问题状态转移方程

### 一维情况

1）最长递增子序列：
`dp[i]` 代表的是以 `x[i]` 为最后一个值的最大长度

```
dp[x] = max(dp[x], dp[y] + 1) if y < x  && nums[x] > nums[y]
result = max(dp)
```

2）最大子序列和 基本思想：如果上一个值为正，则加到现在的这个上

```
dp[i] = dp[i-1] + nums[i] if dp[i-1] > 0
result = max(dp)
```

### 二维情况 -> 矩阵

2) 最长公共子序列： 子序列：可以不连续。 子串：必须连续

```
dp[0][i] = 0
dp[j][0] = 0
# 这两条表示 第一行和第一列均为0
dp[i][j] = dp[i-1][j-1] + 1 if str[i] == str[j]
# 如果相同从斜对角线上+1
dp[i][j] = max(dp[i-1][j],dp[i][j-1]) if str[i] != str[j]
# 如果不同从 上一行或者上一列对应值+1
[[0, 0, 0, 0],
 [0, 1, 1, 1],
 [0, 1, 1, 1],
 [0, 1, 2, 2],
 [0, 1, 2, 2],
 [0, 1, 2, 3]]
```

3）最长公共子串：

4) 编辑距离：

### 其他

5) 0-1 背包问题

```
# F(n,C) : n个物品放进容量为C的背包，两种策略：新加入的物品 +或者不+
F(i,c) = max(F(i-1,c) , v(i) + F(i-1,c-w(i)))
```

6）完全背包问题

每个物品可以无限使用.

```

```

7) 将一个list 分成和相同的两部分 0-1问题变种(leetcode 416)

```
F(i,c) = F(i-1,c) || F(i-1,c -w(i))
```





