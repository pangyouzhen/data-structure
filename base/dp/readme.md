# 什么情况下使用
1） 计数
2） 最值
3）

# 两种方法
1. 记忆化递归
2. dp

# 典型问题状态转移方程
## 一维情况
1）最长递增子序列： 
`dp[i]` 代表的是以 `x[i]` 为最后一个值的最大长度

```
dp[x] = max(dp[x], dp[y] + 1) if y < x  && nums[x] > nums[y]
result = max(dp)
```

2）最大子序列和
基本思想：如果上一个值为正，则加到现在的这个上

```
dp[i] = dp[i-1] + nums[i] if dp[i-1] > 0
result = max(dp)
```

## 二维情况 -> 矩阵
2) 最长公共子序列：
子序列：可以不连续。 子串：必须连续

```
dp[0][i] = 0
dp[j][0] = 0
# 这两条表示 第一行和第一列均为0
dp[i][j] = dp[i-1][j-1] + 1 if str[i] == str[j]
# 如果相同从斜对角线上+1
dp[i][j] = max(dp[i-1][j],dp[i][j-1]) if str[i] != str[j]
# 如果不同从 上一行或者上一列对应值+1
[[0, 0, 0, 0],
 [0, 1, 1, 1],
 [0, 1, 1, 1],
 [0, 1, 2, 2],
 [0, 1, 2, 2],
 [0, 1, 2, 3]]
```


3）最长公共子串：

4) 编辑距离：

## 其他

5) 0-1 背包问题
```
# F(n,C) : n个物品放进容量为C的背包，两种策略：新加入的物品 +或者不+
F(i,c) = max(F(i-1,c) , v(i) + F(i-1,c-w(i)))
```
6）完全背包问题

每个物品可以无限使用.

```

```


7) 将一个list 分成和相同的两部分 0-1问题变种(leetcode 416)
```
F(i,c) = F(i-1,c) || F(i-1,c -w(i))
```





